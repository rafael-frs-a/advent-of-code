# Day 10: Factory

## Link

https://adventofcode.com/2025/day/10#part2

## Solution

To solve part two, I considered a couple of options. First, that this could maybe be reduced to the Coin Change problem, which can be solved with dynamic programming (DP). However, those kinds of problems require calculating the solution for all steps between the base case and the final case. For example, solving for 100 requires finding the solution for all integers between 0 and 100, inclusive. In the case of this problem, since we have to solve for multiple numbers, the number of intermediate cases, defined by their product, would be too high to process in a reasonable time.

Another approach would be making a system of `N` equations with `M` variables, where `N` is the number of joltages and each `M` variable corresponds to the number of times each button is pressed. I usually solve those with [SymPy](https://pypi.org/project/sympy/), which unfortunately doesn't have a Rust equivalent as of the date I solved this. However, `M` is often higher than `N`, which makes most equations unsolvable. I considered restricting each variable to be non-negative and optimizing the sum of the variables to the smallest amount, but I don't know enough about math to apply this idea.

After checking shared solutions on the internet, I found [this](https://topaz.github.io/paste/#XQAAAQDvBAAAAAAAAAAzHIoib6pXbueH4X9F244lVRDcOZab5q1+VXY/ex42qR7D+RJIsrl/Sxb6tPAL/raOnZPNJkY+oaCf3ikJnGCW2VLjcrWl1UWVJsEfoFmWC2mwwsm/9AKE33K8ZQFOVhiZYFzTsKmWP4wIavwXzvTsAt9oBUJpkwZPrJXj9ZwBNh5Iwz5+Z36Un6/utPWTvk3MEl453wY+ot1xZGmKz7rsMqlsgeOCDOYp0UXrT7yqjVRXQVzVdpCwNQ9RSO6FT47uvMX8wQqJD/+blZeDS9Oe1XNzVmGrLLFRk4HWi27CVhhMZ0mOIUgsJqaHoL3lynf0snTT6GwIrGXSjdt8iMDNBQuSefgUPz0I/CWztHGvTp3t2G/I/kKabr1kr+1eRmmfja5cnZDK/QFUsZd0MtDbzPhzYaObbqxHfN42HeEwGc0c/7SmD4j1XameL5/hA5b+8mQ92tGdeq/1H5UJ9e1x15ETCiuLTGpkEXMu4N4srUAUkoSUauGzEfPebQ9rMOakWNWX3fYFuD2CoNqsVmIByrWT4ieJ8bU3UWmlUnhtleusft6d9ZxIUojnltuRBgK/0/FS3jeQzdF4xnjisFYem0TnJbgz8uQtX40aoj/+VjvT++L2iBMHW7MGyCkYW6YoxsK6wOS0uHcOu794V1zc5A3tlPEBuVjwHZE1PZcovutRjh6V7FAORum92PirrnpA5RxKe7FgGFp3KFFMF74KGhY1575VSfepjdk+a8eQlxAeFE4JKVbSqmd6gB4iGtPFv/946UKa) one, which applies my first idea of dynamic programming with an insight to avoid processing all cases. The idea is that, given each button press increases joltages by just one, that is granular enough to assume that if all joltages are even, their solution should be the same as the solution of their halves times two. If the joltages contain odd numbers, we can extract those into a separate case, making a parity vector that tells us whether each joltage is even or odd. For example, in the first case from the problem's example, the initial joltages of `3,5,4,7` would result in the following parity vector: `1,1,0,1`. If we subtract the parity vector from the joltages, we obtain all even numbers that can use the previous idea. However, simply subtracting the parity vector assumes that it is a solvable state, which isn't always the case. In the problem's first example, the state `1,0,0,1` can't be solved. To address that, we should first list all base cases where each button is pressed at most once. We then group each possible state by its respective parity vector. With that, `1,0,0,1` now maps to multiple base states, such as `1,2,0,1` and `1,2,2,3`. Instead of then subtracting the joltage parity vector from itself, we try subtracting each base state corresponding to that parity vector. That should give us a vector with even joltages that can be halved and speed up the recursive approach.

## Instructions

Add an `input.txt` file to the parent folder and run `python solution.py` to see the result.
